# Get Sleeper Newsletter on par with Main League Newsletters

> **Status: ✅ Complete** — All implementation stories finished. Story 8.4 (Usage Guide) superseded by [public-launch-plan.md](public-launch-plan.md), which defines the broader multi-league platform roadmap including commissioner onboarding.

## Executive Summary

This project will enhance the generic Sleeper newsletter ([LeagueWeeklyRecap.tsx](../src/pages/LeagueWeeklyRecap.tsx)) to match the feature parity and data richness of the main league newsletters ([Newsletter.jsx](../src/pages/Newsletter.jsx)). Currently, the main league newsletter displays comprehensive weekly analysis using pre-computed JSON data files from R scripts, while the Sleeper newsletter only shows basic weekly awards. By implementing data transformation utilities in TypeScript, we will enable any Sleeper league to generate the full newsletter experience dynamically from the Sleeper API.

## Context

### Current State

**Main League Newsletter** ([Newsletter.jsx](../src/pages/Newsletter.jsx)):

- Loads pre-computed data from JSON files generated by R scripts (`ff-data-analytics` repository)
- Displays rich content including:
  - Weekly awards with team/player photos
  - Manager efficiency charts
  - Matchup plots with player breakdowns
  - Leaderboards with standings
  - Power rankings
  - Best ball and median scoring leaderboards
  - Playoff standings
  - ~~MotW (Matchup of the Week) history~~ (Main league specific - not needed)
  - ~~Shots/Dogs distribution charts~~ (Main league specific - not needed)
  - ~~Danger zone tables~~ (Main league MotW-specific - not needed)
- Data files required per newsletter (see [newsletters/README.md](../src/newsletters/README.md)):
  - `awardsTable.json` - Awards with photos and descriptions
  - `efficiencyData.json` - Manager skill assessment data
  - `starters.json` - Player performance data for matchup plots
  - `leaderboard.json` - Standings with PF/PA and color coding
  - `matchupData.json` - Matchup statistics
  - `bestBallLb.json` - Best ball leaderboard
  - `medianLb.json` - Median scoring leaderboard
  - `powerRankings.json` - Power rankings
  - ~~`dangerTable.json`~~ (Main league MotW-specific - not needed)
  - `scheduleData.json` - Schedule information
  - `playoffTable.json` - Playoff standings
  - ~~`motwTable.json`~~ (Main league specific - not needed)
  - ~~`shotsDist.json`~~ (Main league specific - not needed)

**Sleeper Newsletter** ([LeagueWeeklyRecap.tsx](../src/pages/LeagueWeeklyRecap.tsx)):

- Fetches data from Sleeper API in real-time
- Only displays basic weekly awards (10 awards)
- Uses [computeWeeklyAwards.ts](../src/utils/awards/computeWeeklyAwards.ts) utility
- Missing: efficiency charts, matchup plots, leaderboards, power rankings, best ball, median scoring

### Key Differences

| Feature            | Main League                             | Sleeper Newsletter | Notes                       |
| ------------------ | --------------------------------------- | ------------------ | --------------------------- |
| Awards             | 16 awards with position-specific awards | 10 basic awards    | Expand to match main league |
| Efficiency Chart   | ✅                                      | ❌                 | Need to implement           |
| Matchup Plots      | ✅                                      | ❌                 | Need to implement           |
| Leaderboard        | ✅                                      | ❌                 | Need to implement           |
| Power Rankings     | ✅                                      | ❌                 | Need to implement           |
| Best Ball          | ✅                                      | ❌                 | Need to implement           |
| Median Scoring     | ✅                                      | ❌                 | Need to implement           |
| MotW History       | ✅                                      | N/A                | Main league specific - skip |
| Shots Distribution | ✅                                      | N/A                | Main league specific - skip |
| Danger Zone        | ✅                                      | N/A                | Main league MotW - skip     |
| Data Source        | Pre-computed JSON                       | Real-time API      | Keep API-based approach     |

## Goals

1. **Feature Parity**: Enable Sleeper newsletters to display all features available in main league newsletters
2. **Data Generation**: Create TypeScript utilities to transform Sleeper API data into the JSON formats expected by existing newsletter components
3. **Reusability**: Build modular utilities that can be used for any Sleeper league
4. **Performance**: Implement efficient data fetching and transformation with appropriate caching
5. **Maintainability**: Ensure code is well-typed, documented, and follows existing patterns

## Technical Approach

### Architecture

The solution will follow a layered architecture:

```
Sleeper API
    ↓
API Layer (SleeperAPI.ts) - Already exists
    ↓
Data Transformation Layer (NEW) - Transform raw API data to newsletter JSON formats
    ↓
Newsletter Components (newsStyles.jsx) - Already exist
    ↓
LeagueWeeklyRecap.tsx - Updated to use new utilities
```

### Design Decisions

1. **Separate Concerns**: Create dedicated utility files for each data transformation type
2. **TypeScript First**: All new utilities will be in TypeScript with proper type definitions
3. **Leverage Existing Code**: Reuse [computeWeeklyAwards.ts](../src/utils/awards/computeWeeklyAwards.ts) pattern for new utilities
4. **API-Based Only**: No Firebase/Firestore - all data fetched directly from Sleeper API
5. **Multi-Week Queries**: For power rankings and trends, fetch multiple weeks of data via Sleeper API
6. **React Query Integration**: Use `@tanstack/react-query` for caching and data fetching
7. **Incremental Development**: Build utilities one-by-one and test with existing components
8. **Nicknames**: Team nicknames from `roster.metadata.team_name`, player nicknames from `roster.metadata.player_map[playerId]` (custom names set by managers in Sleeper)
9. **Color Scheme**: Same gradient as main league (red #bc293d to green #227740), not configurable
10. **Playoff Handling**: Detect via `league.settings.playoff_week_start`, conditionally hide standings/power rankings during playoffs

## Implementation Plan

### Phase 1: Foundation & Data Models

**Duration**: Foundation for all subsequent work

**Tasks**:

1. **Create Type Definitions**
   - File: `src/types/newsletterTypes.ts`
   - Define interfaces for all JSON data formats:
     - `AwardsTable` (already exists in `computeWeeklyAwards.ts`)
     - `EfficiencyData`
     - `StartersData`
     - `LeaderboardData`
     - `MatchupData`
     - `BestBallData`
     - `MedianData`
     - `PowerRankingsData`
     - ~~`DangerTableData`~~ (Main league MotW-specific - not needed)
     - `ScheduleData`
     - `PlayoffTableData`
     - ~~`MotwTableData`~~ (Main league specific - not needed)
     - ~~`ShotsDistData`~~ (Main league specific - not needed)
   - Extract examples from existing JSON files in `src/newsletters/2025/2025 Week 1/`

2. **Extend Sleeper API Types**
   - File: `src/types/sleeperTypes.ts`
   - Add `metadata` field to `Roster` interface with `player_map` for custom player nicknames
   - Player nicknames are set by managers in Sleeper and stored in `roster.metadata.player_map[playerId]`
   - Add missing fields discovered during implementation
   - Document any undocumented Sleeper API fields

**Deliverables**:

- Complete type definitions for all newsletter data formats
- Updated Sleeper API types

### Phase 2: Core Data Transformations

**Duration**: Core utilities for primary newsletter features

**Tasks**:

1. **Leaderboard Utility**
   - File: `src/utils/newsletter/computeLeaderboard.ts`
   - Function: `computeLeaderboard(leagueId: string, throughWeek: number): Promise<LeaderboardData[]>`
   - Aggregate roster data through specified week
   - Calculate W/L records, PF, PA
   - Generate color coding for PF/PA (gradient from red to green, same as main league)
   - Sort by wins then points for
   - Include avatar URLs and team nicknames from Sleeper API (`roster.metadata.team_name`)

2. **Starters/Matchup Plot Utility**
   - File: `src/utils/newsletter/computeStarters.ts`
   - Function: `computeStarters(leagueId: string, week: number): Promise<StartersData[]>`
   - Transform matchup data into format for `MatchupPlot` component
   - Include player full names, positions, points
   - Include team nicknames from Sleeper API (`roster.metadata.team_name`)
   - Group by team and matchup
   - Integrate with `sleeper_players.json` for player metadata

3. **Efficiency Chart Utility**
   - File: `src/utils/newsletter/computeEfficiency.ts`
   - Function: `computeEfficiency(leagueId: string, week: number): Promise<EfficiencyData[]>`
   - Calculate optimal lineup for each roster
   - Compare actual score vs. optimal score
   - Calculate efficiency percentage
   - Include team names and metadata
   - Handle bench points calculation

4. **Enhanced Awards Utility**
   - File: `src/utils/awards/computeWeeklyAwards.ts` (update existing)
   - Add position-specific awards:
     - "Literally Throwing" (best QB)
     - "Running Wild" (best RB)
     - "Widest Receiver" (best WR)
     - "Tightest End" (best TE)
     - "Das Boot" (best K)
     - "Biggest D" (best DEF)
   - Add team-based awards:
     - "Warmest Bench" (most bench points)
     - "Heaviest Top" (most optimized lineup)
   - Expand from current 10 awards to match main league feature set

**Deliverables**:

- Four core transformation utilities with tests
- Updated awards utility with full feature set

### Phase 3: Advanced Analytics

**Duration**: More complex calculations and aggregations

**Tasks**:

1. **Best Ball Leaderboard Utility**
   - File: `src/utils/newsletter/computeBestBall.ts`
   - Function: `computeBestBall(leagueId: string, throughWeek: number): Promise<BestBallData[]>`
   - Calculate optimal lineup for each week
   - Aggregate "best ball" record (W/L if optimal lineup was used)
   - Compare to actual record
   - Calculate total optimal points vs actual points

2. **Median Scoring Leaderboard Utility**
   - File: `src/utils/newsletter/computeMedian.ts`
   - Function: `computeMedian(leagueId: string, throughWeek: number): Promise<MedianData[]>`
   - Calculate median score for each week
   - Track wins/losses against median
   - Aggregate season-long median record
   - Calculate median points differential

**Deliverables**:

- Two advanced analytics utilities

### Phase 4: Power Rankings & Analytics

**Duration**: Features requiring multi-week aggregation

**Tasks**:

1. **Power Rankings Utility**
   - File: `src/utils/newsletter/computePowerRankings.ts`
   - Function: `computePowerRankings(leagueId: string, throughWeek: number): Promise<PowerRankingsData[]>`
   - Fetch matchup data for weeks 1 through `throughWeek` via Sleeper API
   - Implement weighted play-all algorithm:
     - **Rank teams by points each week**: Rank = 1 (highest) to N (lowest)
     - **Convert to play-all wins/losses**: wins = N - rank, losses = rank - 1
     - **Apply recency weights**: current week 2.0, then 1.8, 1.6, 1.4, 1.2, else 1.0
     - **Sum weighted wins**: Sum (play-all wins × week weight) for each team
     - **Calculate strength of schedule**: Mean of (N - opponent's weekly rank) across all weeks
     - **Rank teams**: By descending weighted wins, tiebreak by descending SOS
     - **Calculate trend**: Recompute without current week, trend = last rank - current rank
   - Works with any number of weeks (week 1: no trend data, that's fine)
   - Cache multi-week data efficiently with React Query
   - **Example**: 12-team league, week 5, team ranks [3,1,4,2,1] → weighted wins = (9×1.0)+(11×1.2)+(8×1.4)+(10×1.8)+(11×2.0) = 73.4

2. **Schedule Data Utility**
   - File: `src/utils/newsletter/computeSchedule.ts`
   - Function: `computeSchedule(leagueId: string, throughWeek: number): Promise<ScheduleData>`
   - Fetch all matchups through current week
   - For each team, calculate hypothetical records with every other team's schedule:
     - Simulate playing each team's opponents with your scores
     - Track wins/losses/ties for each hypothetical schedule
   - Calculate best-case record (which schedule would give you the most wins)
   - Calculate worst-case record (which schedule would give you the fewest wins)
   - Include current actual record for comparison
   - Format: `{ best_records, worst_records, current_records }` with team names, W/L/T, and list of teams whose schedule produces that record

**Deliverables**:

- Two multi-week analytics utilities
- Documentation on power rankings algorithm
- Efficient caching strategy for multi-week data

### Phase 5: Matchup & Playoff Analytics

**Duration**: Playoff-specific features and scoring distribution analysis

**Tasks**:

1. **Playoff Table Utility**
   - File: `src/utils/newsletter/computePlayoffStandings.ts`
   - Function: `computePlayoffStandings(leagueId: string, currentWeek: number): Promise<PlayoffTableData[]>`
   - Fetch league playoff settings (playoff teams, weeks)
   - Calculate current playoff seeding
   - Calculate magic numbers for clinching/elimination
   - Project playoff scenarios

2. **Matchup Data Utility** (Weekly Scoring Distribution & Margin of Victory)
   - File: `src/utils/newsletter/computeMatchupData.ts`
   - Function: `computeMatchupData(leagueId: string, currentWeek: number): Promise<MatchupData[]>`
   - Fetch all matchup data from week 1 through currentWeek
   - Calculate weekly league statistics (Average, Median, Maximum, Minimum)
   - Calculate margin of victory for each matchup
   - Color code close matchups (within 5 points)
   - Format data for three visualizations:
     - **StackedHistogram**: Distribution of weekly scoring
     - **WeeklyScoringChart**: Weekly statistics over time (Average, Median, Max, Min)
     - **WeeklyMarginTable**: W-L records with weekly margin of victory
   - **Note**: These features were initially missing from the project plan but are present in all main league newsletters

**Deliverables**:

- Two utilities supporting matchup analysis and playoff tracking
- Support for both regular season and playoff weeks
- Three scoring distribution visualizations matching main league newsletter format:
  - Distribution of Scoring (StackedHistogram)
  - Weekly Scoring Chart (Average/Median/Max/Min trends)
  - Weekly Margin of Victory Table (color-coded close matchups)

### Phase 6: UI Integration

**Duration**: Connect utilities to newsletter page

**Tasks**:

1. **Update LeagueWeeklyRecap Component**
   - File: `src/pages/LeagueWeeklyRecap.tsx`
   - Add state management for all data types
   - Create custom hooks for data fetching
   - Implement React Query integration
   - Add loading states and error handling
   - Progressive enhancement (show what's loaded)

2. **Create Custom Hooks**
   - File: `src/hooks/useNewsletterData.ts`
   - Hook: `useNewsletterData(leagueId: string, week: number)`
   - Orchestrate all data fetching
   - Handle parallel requests
   - Manage loading/error states
   - Cache with React Query

3. **Add Newsletter Sections**
   - Import and use existing newsletter components:
     - `EfficiencyChart`
     - `MatchupPlot`
     - `LeaderboardTable`
     - `AltLeaderboardTable` (for best ball/median)
     - Power rankings display (may need new component)
   - Layout similar to main league newsletters
   - Responsive masonry grid
   - **Playoff week handling**: Conditionally render sections based on `league.settings.playoff_week_start`
     - **Regular season**: Show all sections (awards, matchups, standings, power rankings, playoff outlook, alternate universes)
     - **Playoff weeks**: Show only awards, active matchup recaps, scoring distributions (skip standings, power rankings, playoff outlook once playoffs begin)

4. **Create Article Components**
   - File: `src/pages/LeagueWeeklyRecap.tsx` (inline components)
   - Break newsletter into articles:
     - Awards and Recap Article
     - Individual Matchup Articles (dynamic based on league size)
     - Standings Article
     - Power Rankings Article
     - Alternate Universe Article (best ball, median)
     - Playoff Standings Article (when applicable)

**Deliverables**:

- Fully functional newsletter page with all features
- Custom hooks for data management
- Responsive layout with all newsletter components

### Phase 7: Performance & Polish

**Duration**: Optimization and user experience improvements

**Tasks**:

1. **Caching Strategy**
   - Implement React Query cache configuration
   - Set appropriate stale times
   - Implement cache invalidation
   - Add optimistic updates where applicable

2. **Loading States**
   - Skeleton loaders for each section
   - Progressive rendering (show completed sections first)
   - Loading indicators
   - Error boundaries

3. **Error Handling**
   - Graceful degradation for missing data
   - User-friendly error messages
   - Retry logic for failed requests
   - Fallback UI for each section

4. **Performance Optimization**
   - Implement request batching
   - Parallel data fetching
   - Memoization of expensive calculations
   - Code splitting for newsletter components

**Deliverables**:

- Optimized data fetching with sub-2s load times
- Comprehensive error handling
- Polished loading states

### Phase 8: Testing & Documentation

**Duration**: Quality assurance and knowledge transfer

**Tasks**:

1. **Unit Tests**
   - Test each transformation utility
   - Mock Sleeper API responses
   - Test edge cases (ties, empty rosters, etc.)
   - Aim for 80%+ coverage

2. **Integration Tests**
   - Test full newsletter generation flow
   - Test with real Sleeper league data
   - Test error scenarios
   - Test with different league configurations

3. **Documentation**
   - Update `CLAUDE.md` with new utilities
   - Document multi-week data fetching strategy
   - Create examples for each utility
   - Document caching strategy and performance considerations

4. **Usage Guide**
   - Document how to use for any Sleeper league
   - Document URL pattern for accessing newsletters
   - Create troubleshooting guide
   - Document performance expectations and limitations

**Deliverables**:

- Test suite with 80%+ coverage
- Comprehensive documentation
- Usage guide for Sleeper leagues

## File Structure

```
src/
├── types/
│   └── newsletterTypes.ts (NEW)
├── utils/
│   └── newsletter/ (NEW DIRECTORY)
│      ├── computeLeaderboard.ts
│      ├── computeStarters.ts
│      ├── computeEfficiency.ts
│      ├── computeBestBall.ts
│      ├── computeMedian.ts
│      ├── computePowerRankings.ts
│      ├── computeSchedule.ts
│      ├── computePlayoffStandings.ts
│      ├── computeMatchupData.ts
│      └── computeWeeklyAwards.ts (UPDATE)
├── hooks/
│   └── useNewsletterData.ts (NEW)
└── pages/
    └── LeagueWeeklyRecap.tsx (UPDATE)
```

## Dependencies

### Existing Dependencies (No Changes Required)

- `@tanstack/react-query` - Data fetching and caching
- `react-router-dom` - Routing
- Existing newsletter components in `src/components/newsletters/`

### Potential New Dependencies

- None expected - all functionality achievable with existing dependencies

## Data Requirements

### Sleeper API Multi-Week Data Strategy

For features requiring historical data (power rankings, trends), we'll fetch multiple weeks of matchup data from the Sleeper API:

**Example**: To compute power rankings for week 8:

```typescript
// Fetch weeks 1-8 matchups in parallel
const weeklyMatchups = await Promise.all(
  Array.from({ length: 8 }, (_, i) => getMatchups(leagueId, i + 1)),
);
```

**Caching Strategy**:

- Use React Query to cache each week's matchup data independently
- Cache keys: `['matchups', leagueId, week]`
- Stale time: 1 hour for completed weeks, 5 minutes for current week
- Historical weeks (completed) can have infinite stale time

## Testing Strategy

### Unit Testing

- Each utility function tested independently
- Mock Sleeper API responses
- Test edge cases: ties, bye weeks, incomplete rosters
- Test data transformations for correctness

### Integration Testing

- Test full newsletter generation for a sample league
- Test with multiple league configurations
- Test error handling and recovery

### Manual Testing

- Test with main league (compare to R-generated results)
- Test with different Sleeper leagues (various sizes, settings)
- Test loading states and performance
- Cross-browser testing

## Risk Assessment

### Technical Risks

| Risk                                    | Impact | Likelihood | Mitigation                                      |
| --------------------------------------- | ------ | ---------- | ----------------------------------------------- |
| Sleeper API rate limiting               | High   | Medium     | Implement request batching and aggressive cache |
| Missing Sleeper API data                | High   | Medium     | Graceful degradation, clear error messages      |
| Performance with multi-week queries     | Medium | Medium     | Parallel fetching, React Query caching          |
| Breaking changes to existing components | High   | Low        | Thorough testing, incremental rollout           |

### Implementation Risks

| Risk                             | Impact | Likelihood | Mitigation                              |
| -------------------------------- | ------ | ---------- | --------------------------------------- |
| Complex power rankings algorithm | Medium | Medium     | Start simple, iterate based on feedback |
| Type definition drift            | Low    | Medium     | Extract types from actual API responses |
| Nickname generation strategy     | Low    | Low        | Use player names only, skip nicknames   |

## Success Criteria

1. **Functionality**: All newsletter sections render correctly for any Sleeper league (awards, efficiency, matchup plots, leaderboards, power rankings, best ball, median scoring, playoff standings)
2. **Performance**: Newsletter loads in under 3 seconds for typical leagues (12 teams, current week)
3. **Accuracy**: Data calculations match main league R script outputs within 0.1%
4. **Usability**: Clear loading states and error messages for each section
5. **Maintainability**: Well-typed, documented, and tested code
6. **Reusability**: Can be used for any Sleeper league with zero configuration

## Notes from Review

**Scope Clarifications**:

- MotW (Matchup of the Week), Shots/Dogs distribution, and Danger Zone features are main league-specific and will NOT be replicated for generic Sleeper newsletters
- No Firebase/Firestore dependency - all data fetched directly from Sleeper API
- Power rankings and historical features will be implemented by fetching multiple weeks of data via Sleeper API
- Focus on zero-configuration solution that works for any Sleeper league

## Implementation Stories

This high-level plan has been broken down into **22 individual stories** for implementation using the pair programming workflow.

**Story Location**: `aigen/stories/`

**Story Index**: See [stories/STORIES_README.md](stories/STORIES_README.md) for complete story list and progress tracking.

**Next Step**: Start with [Story 1.1: Create Newsletter Type Definitions](stories/story_1_1.md)

### Story Breakdown

- **Phase 1** (Foundation): 2 stories
- **Phase 2** (Core Transformations): 4 stories
- **Phase 3** (Advanced Analytics): 2 stories
- **Phase 4** (Power Rankings): 2 stories
- **Phase 5** (Playoff Analytics): 1 story
- **Phase 6** (UI Integration): 2 stories
- **Phase 7** (Performance): 4 stories
- **Phase 8** (Testing & Docs): 4 stories

Each story includes:

- Clear acceptance criteria
- Specific human testing steps
- Expected visual and functional results
- Dependencies on other stories
- Implementation notes and algorithms
